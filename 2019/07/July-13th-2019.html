<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Jordan Vidrine Coding Journal - July 13th 2019</title>
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <link rel="stylesheet" href="/assets/css/page-styles.css">
    <link href="https://fonts.googleapis.com/css?family=Cabin:600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id='title-nav'>
      <h1>Coding Journal</h1>
      <nav>
  
  
    <a href="/" >
      Home
    </a>
    
  
    <a href="/blog" >
      Blog
    </a>
    
  
    <a href="https://www.linkedin.com/in/jordan-b-vidrine/" >
      LinkedIn
    </a>
    
</nav>

      <div id='bio'>
              <img src="/assets/img/profile.jpg">
        <h3>Jordan Vidrine</h3>
        <span>Daily Coding Journal</span>
        <p>
          An experienced business owner + musician with a demonstrated history of management in the
          Energy sector and an insatiable appetite for learning new and complex skills. Transitioning
          from an ownership role & seeking employment in Web Development as a Jr Full Stack Developer.
        </p>
      </div>
    </div>
    <div id="posts">
    <div id="content">
    <h2>July 13th 2019</h2>
    <p>So Hurricane Barry is making its way to land. Im posted up at my parents house in case the power back home goes out. I’ve been reading a bit of SICP which apparently is a computer programmer’s/CS Major’s dream book. I’ve also been going through MIT lectures on the book and I find it very interesting.</p>

<p>The language it will be focused on is a dialect of Lisp called Scheme. This all comes recommended to my by a friend who’s has his degree in CS. I think it’s a good reccomendation as the book is going through the basic building blocks of what programs are, of what interpreters are, and what is actually going on behind the scenes when we write programs. I love this type of stuff, taking it all apart is so interesting to me.</p>

<p>Anyway! That being said, I felt it necessary to also go back to the Regex section of Eloquent Javascript. Why? Because in it is a section on writing a parsing function that interprets an INI file using regex statements. Here is the example the book gives.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">parseINI</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Start with an object to hold the top-level fields</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">let</span> <span class="nx">section</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
  <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\r?\n</span><span class="sr">/</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">line</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">match</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">(\w</span><span class="sr">+</span><span class="se">)</span><span class="sr">=</span><span class="se">(</span><span class="sr">.*</span><span class="se">)</span><span class="sr">$/</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">section</span><span class="p">[</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">\[(</span><span class="sr">.*</span><span class="se">)\]</span><span class="sr">$/</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">section</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="sr">/^</span><span class="se">\s</span><span class="sr">*</span><span class="se">(</span><span class="sr">;.*</span><span class="se">)?</span><span class="sr">$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">line</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Line '</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">line</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">' is not valid.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<!--more-->
<p>What’s happening is here the parseINI function is being fed a string. It splits that string up with any new line or return with <code class="highlighter-rouge">/\r?\n/</code> as a regex passed to the split method on a string.</p>

<p>It then goes through each line and tests it to see if it a line that either declares a new section with <code class="highlighter-rouge">[newSectionText]</code> or if it defines a key in the current section it is on with something like <code class="highlighter-rouge">newKey=newKeyText</code></p>

<p>So what the above code does to a .INI file like this:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name=Vasilis
[address]
city=Tessaloniki
</code></pre></div></div>
<p>Would be to turn it into an object like this:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Vasilis</span><span class="dl">"</span><span class="p">,</span> <span class="nx">address</span><span class="p">:</span> <span class="p">{</span><span class="nl">city</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Tessaloniki</span><span class="dl">"</span><span class="p">}}</span>
</code></pre></div></div>
<p>A couple of interesting things to note for me were the defining of a variable inside of an if statement. <code class="highlighter-rouge">if (match = line.match(/^(\w+)=(.*)$/))</code> will evaluate the object that is assigned to match immediately. If nothing gets assigned to it, the if statement moves on.</p>

<p>Another interesting thing is that on the first else if statement, we re-assign the section variable to a new empty object we are defining in result at the same time we are assigning it. This allows us to edit the current section we are in on the next .forEach line. I would have thought we would have used recursion for this, but since we are calling section as a reference to an object in result. Any edits we make to that section are also made in result.</p>

<h4 id="ejs-ch-12-a-programming-language">EJS Ch 12 ‘A Programming Language’</h4>
<p>In this chapter we go through a process of how a program is parsed. It is very similar to the first chapter of SICP that I am going through and this lines up perfectly with it. I put the following code from the book into a google code snippet and ran through the debugger line by line to see what was going on. It was pretty complex, but it made sense to me. Very cool!</p>

<p>What thw following code gives back is a Syntax Tree of the program you pass to it.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// PARSE EXPRESSION</span>
<span class="kd">function</span> <span class="nx">parseExpression</span><span class="p">(</span><span class="nx">program</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">program</span> <span class="o">=</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">program</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">match</span><span class="p">,</span> <span class="nx">expr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="sr">/^"</span><span class="se">([^</span><span class="sr">"</span><span class="se">]</span><span class="sr">*</span><span class="se">)</span><span class="sr">"/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">program</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">expr</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">\d</span><span class="sr">+</span><span class="se">\b</span><span class="sr">/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">program</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">expr</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">[^\s</span><span class="sr">(),#"</span><span class="se">]</span><span class="sr">+/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">program</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">expr</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">word</span><span class="dl">"</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="nx">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unexpected syntax: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">program</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">parseApply</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// SKIP SPACE</span>
<span class="kd">function</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">string</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="sr">/</span><span class="se">\S</span><span class="sr">/</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">string</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// PARSE APPLY</span>
<span class="kd">function</span> <span class="nx">parseApply</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">program</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">program</span> <span class="o">=</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">program</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">program</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="na">expr</span><span class="p">:</span> <span class="nx">expr</span><span class="p">,</span> <span class="na">rest</span><span class="p">:</span> <span class="nx">program</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">program</span> <span class="o">=</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="nx">expr</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">apply</span><span class="dl">"</span><span class="p">,</span> <span class="na">operator</span><span class="p">:</span> <span class="nx">expr</span><span class="p">,</span> <span class="na">args</span><span class="p">:</span> <span class="p">[]};</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">program</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arg</span> <span class="o">=</span> <span class="nx">parseExpression</span><span class="p">(</span><span class="nx">program</span><span class="p">);</span>
    <span class="nx">expr</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">expr</span><span class="p">);</span>
    <span class="nx">program</span> <span class="o">=</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">rest</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">program</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">program</span> <span class="o">=</span> <span class="nx">skipSpace</span><span class="p">(</span><span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">program</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="dl">"</span><span class="s2">Expected ',' or ')'</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">parseApply</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">parse</span><span class="p">(</span><span class="nx">program</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">debugger</span><span class="p">;</span>
  <span class="kd">let</span> <span class="p">{</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">rest</span><span class="p">}</span> <span class="o">=</span> <span class="nx">parseExpression</span><span class="p">(</span><span class="nx">program</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">skipSpace</span><span class="p">(</span><span class="nx">rest</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unexpected text after program</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">expr</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="dl">"</span><span class="s2">+(a, 10)</span><span class="dl">"</span><span class="p">));</span>

<span class="c1">// → {type: "apply",</span>
<span class="c1">//    operator: {type: "word", name: "+"},</span>
<span class="c1">//    args: [{type: "word", name: "a"},</span>
<span class="c1">//           {type: "value", value: 10}]}</span>
</code></pre></div></div>

<p>Obviously, way more needs to happen in order for code to be ‘run’. We need to evaluate this syntax tree and figure out what it is trying to tell us. That we will cover in the next section of the chapter.</p>

    <a id='back' href="/blog/index.html">Back to blog...</a>
  </div>
    </div>
    <footer>
<p>Created with Jekyll by Jordan Vidrine - <a href="https://www.linkedin.com/in/jordan-b-vidrine/">LinkedIn</a> - <a href="https://github.com/jordanvidrine">GitHub</a></p>
</footer>
</section>


  </body>
</html>
